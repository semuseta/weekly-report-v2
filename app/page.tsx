"use client"

import { useState } from "react"

type ApiResult = {
  rowsCount?: number
  sumHours?: number
  averageHours?: number
  invalidValues?: number
  preview?: any[]
  error?: string
}

export default function Home() {
  const [loading, setLoading] = useState(false)
  const [result, setResult] = useState<ApiResult | null>(null)
  const [showPreview, setShowPreview] = useState(false)

  async function handleFile(e: React.ChangeEvent<HTMLInputElement>) {
    const file = e.target.files?.[0]
    if (!file) return
    setLoading(true)
    setResult(null)
    try {
      const ab = await file.arrayBuffer()
      const res = await fetch("/api/upload", {
        method: "POST",
        headers: {
          "x-filename": file.name,
          "content-type": "application/octet-stream",
        },
        body: ab,
      })
      const data = await res.json()
      if (!res.ok) {
        setResult({ error: data?.error || 'Upload fehlgeschlagen' })
      } else {
        setResult(data)
      }
    } catch (err) {
      setResult({ error: String(err) })
    } finally {
      setLoading(false)
    }
  }

  async function handleDownloadPdf() {
    if (!result || result.error) return

    // Generate HTML report directly in browser - no server PDF needed!
    const htmlContent = `
<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <title>Weekly Report</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 40px; line-height: 1.6; color: #333; }
    .page-break { page-break-after: always; margin-top: 40px; }
    .header { font-size: 28px; font-weight: bold; text-align: center; margin-bottom: 20px; }
    .subtitle { text-align: center; font-size: 12px; color: #666; }
    .kpi-box { border: 1px solid #333; padding: 20px; width: 140px; display: inline-block; margin: 10px; text-align: center; }
    .kpi-value { font-size: 22px; font-weight: bold; color: #2c3e50; }
    .kpi-label { font-size: 11px; margin-top: 10px; color: #666; }
    table { width: 100%; border-collapse: collapse; margin-top: 20px; }
    th, td { border: 1px solid #ddd; padding: 12px; text-align: left; }
    th { background-color: #f5f5f5; font-weight: bold; }
    .bullet { margin: 12px 0; padding-left: 25px; line-height: 1.8; }
    h2 { border-bottom: 2px solid #333; padding-bottom: 10px; }
    .footer { margin-top: 30px; font-size: 11px; color: #999; text-align: center; }
  </style>
</head>
<body>
  <!-- PAGE 1: COVER -->
  <div class="header">WEEKLY CONSULTING REPORT</div>
  <p class="subtitle">Week Report</p>
  <p class="subtitle">Report erstellt: ${new Date().toLocaleDateString('de-DE')}</p>
  <p class="subtitle" style="margin-top: 40px;">Generated by Weekly Report Tool</p>
  
  <!-- PAGE 2: EXECUTIVE SUMMARY -->
  <div class="page-break"></div>
  <h2>EXECUTIVE SUMMARY</h2>
  <div class="bullet">✓ Im Berichtszeitraum wurden ${formatNumberDe(result.sumHours, 1)} Stunden Beratung geleistet.</div>
  <div class="bullet">✓ Verteilung auf ${result.rowsCount} Einträge mit durchschnittlich ${formatNumberDe(result.averageHours, 1)} Stunden pro Eintrag.</div>
  <div class="bullet">✓ Alle KPIs im Zielkorridor. Status: ✓ ON TRACK</div>
  
  <!-- PAGE 3: KEY PERFORMANCE INDICATORS -->
  <div class="page-break"></div>
  <h2>KEY PERFORMANCE INDICATORS</h2>
  <div>
    <div class="kpi-box">
      <div class="kpi-value">${formatNumberDe(result.sumHours, 1)}h</div>
      <div class="kpi-label">Gesamt-Stunden</div>
    </div>
    <div class="kpi-box">
      <div class="kpi-value">${result.rowsCount}</div>
      <div class="kpi-label">Anzahl Einträge</div>
    </div>
    <div class="kpi-box">
      <div class="kpi-value">${formatNumberDe(result.averageHours, 1)}h</div>
      <div class="kpi-label">Ø pro Eintrag</div>
    </div>
  </div>
  
  <!-- PAGE 4: PROJECT BREAKDOWN -->
  <div class="page-break"></div>
  <h2>PROJECT BREAKDOWN</h2>
  <table>
    <tr>
      <th>Projekt</th>
      <th>Stunden</th>
      <th>Anteil</th>
    </tr>
    ${(() => {
      const projectHours: Record<string, number> = {}
      result.preview?.forEach((entry: any) => {
        const proj = entry.project || 'Unbenannt'
        projectHours[proj] = (projectHours[proj] || 0) + (parseFloat(entry.hours) || 0)
      })
      return Object.entries(projectHours)
        .sort((a, b) => b[1] - a[1])
        .map(
          ([project, hours]) => \`
          <tr>
            <td>\${project}</td>
            <td>\${formatNumberDe(hours as number, 1)}h</td>
            <td>\${((hours as number / result.sumHours) * 100).toFixed(0)}%</td>
          </tr>
        \`
        )
        .join('')
    })()}
  </table>
  
  <!-- PAGE 5: NEXT STEPS -->
  <div class="page-break"></div>
  <h2>NEXT STEPS & SUMMARY</h2>
  <p><strong>✓ Diese Woche</strong></p>
  <ul>
    <li>${result.rowsCount} Einträge erfasst</li>
    <li>${formatNumberDe(result.sumHours, 1)} Stunden geleistet</li>
    <li>Alle KPIs im Zielkorridor</li>
  </ul>
  
  <p><strong>→ Nächste Woche</strong></p>
  <ul>
    <li>Kapazitätsplanung überprüfen</li>
    <li>Stakeholder-Alignment durchführen</li>
    <li>Nächster Report: folgende Woche</li>
  </ul>
  
  <div class="footer">
    <p>Weekly Report Tool | Generiert automatisch am ${new Date().toLocaleDateString('de-DE')}</p>
  </div>
</body>
</html>
    `

    // Download as HTML (browsers can open/print as PDF)
    const blob = new Blob([htmlContent], { type: 'text/html' })
    const url = URL.createObjectURL(blob)
    const a = document.createElement('a')
    a.href = url
    a.download = `weekly-report-${new Date().toISOString().split('T')[0]}.html`
    a.click()
    URL.revokeObjectURL(url)
  }

  return (
    <main style={{ padding: 24, fontFamily: 'Inter, system-ui, sans-serif' }}>
      <h1>Wöchentliches Reporting — Upload</h1>
      <p>Wähle eine CSV- oder Excel-Datei (.csv, .xlsx, .xls)</p>
      <input disabled={loading} type="file" accept=".csv,.xlsx,.xls" onChange={handleFile} />

      {loading && <p>Verarbeite Datei…</p>}

      {result && (
        <section style={{ marginTop: 20 }}>
          <h2>KPIs</h2>
          {result.error ? (
            <div style={{ color: 'crimson' }}>
              <strong>Fehler:</strong> {result.error}
            </div>
          ) : (
            <div>
              <ul>
                <li><strong>Zeilen (rowsCount):</strong> {formatNumberDe(result.rowsCount, 0)}</li>
                <li><strong>Summe Stunden (sumHours):</strong> {formatNumberDe(result.sumHours, 2)}</li>
                <li><strong>Durchschnitt Stunden / Eintrag (averageHours):</strong> {formatNumberDe(result.averageHours, 2)}</li>
                <li><strong>Ungültige Werte (invalidValues):</strong> {formatNumberDe(result.invalidValues, 0)}</li>
              </ul>

              {/* Regelbasierte, kurze Text-Zusammenfassung (Frontend) */}
              <div style={{ marginTop: 12 }}>
                <SummaryDisplay result={result} />
              </div>

              <div style={{ marginTop: 16 }}>
                <button onClick={handleDownloadPdf}>
                  Report herunterladen (HTML)
                </button>
              </div>

              {result.preview && (
                <div style={{ marginTop: 8 }}>
                  <button onClick={() => setShowPreview(v => !v)}>
                    {showPreview ? 'Vorschau verbergen' : 'Vorschau anzeigen'}
                  </button>
                  {showPreview && (
                    <pre style={{ whiteSpace: 'pre-wrap', background: '#f6f8fa', padding: 12, marginTop: 8 }}>
                      {JSON.stringify(result.preview, null, 2)}
                    </pre>
                  )}
                </div>
              )}
            </div>
          )}
        </section>
      )}
    </main>
  )
}

function formatNumberDe(value?: number, decimals = 2) {
  if (value === null || value === undefined || Number.isNaN(Number(value))) return '—'
  const opts: Intl.NumberFormatOptions = { minimumFractionDigits: decimals, maximumFractionDigits: decimals }
  return new Intl.NumberFormat('de-DE', opts).format(Number(value))
}

function SummaryDisplay({ result }: { result: ApiResult }) {
  const rows = result.rowsCount ?? 0
  const fmt = (n?: number) => formatNumberDe(n, 2)

  if (rows === 0) {
    return <p>Für den ausgewählten Zeitraum liegen keine auswertbaren Einträge vor.</p>
  }

  return (
    <div>
      <p>
        In diesem Zeitraum wurden {formatNumberDe(rows, 0)} Einträge erfasst mit insgesamt {fmt(result.sumHours)} Stunden. Der
        durchschnittliche Aufwand pro Eintrag beträgt {fmt(result.averageHours)} Stunden.
      </p>
      {result.invalidValues && result.invalidValues > 0 && (
        <p>{formatNumberDe(result.invalidValues, 0)} Einträge enthielten ungültige oder leere Werte und wurden bei der Berechnung ignoriert.</p>
      )}
    </div>
  )
}
